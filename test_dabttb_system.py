#!/usr/bin/env python3
"""
DABTTB System Validation Test Suite

Comprehensive test suite to validate the DABTTB (Advanced Table Tennis Ball Tracking) 
system before GitHub upload. Tests all core functionality including:
- API endpoints
- Database connectivity
- AI model loading
- Analytics dashboard
- Data quality assurance

Computer Science Project - London BSc Computer Systems Engineering
London South Bank University
"""

import requests
import time
import json
import sys
from typing import Dict, Any, List
from datetime import datetime

class DABTTBSystemTester:
    """Comprehensive system tester for DABTTB project"""
    
    def __init__(self, base_url: str = "http://localhost:8005"):
        self.base_url = base_url
        self.test_results = []
        self.start_time = datetime.now()
        
    def log_test(self, test_name: str, success: bool, message: str = "", details: Any = None):
        """Log test result"""
        result = {
            "test": test_name,
            "success": success,
            "message": message,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        self.test_results.append(result)
        
        status = "‚úÖ PASS" if success else "‚ùå FAIL"
        print(f"{status} {test_name}: {message}")
        
        if details and not success:
            print(f"    Details: {details}")
    
    def test_service_health(self) -> bool:
        """Test if DABTTB AI service is healthy"""
        try:
            response = requests.get(f"{self.base_url}/health", timeout=10)
            
            if response.status_code == 200:
                health_data = response.json()
                is_healthy = health_data.get("status") == "healthy"
                
                self.log_test(
                    "Service Health Check", 
                    is_healthy,
                    f"Service status: {health_data.get('status', 'unknown')}",
                    health_data
                )
                return is_healthy
            else:
                self.log_test(
                    "Service Health Check", 
                    False,
                    f"HTTP {response.status_code}",
                    response.text
                )
                return False
                
        except Exception as e:
            self.log_test(
                "Service Health Check", 
                False,
                f"Connection failed: {str(e)}"
            )
            return False
    
    def test_root_endpoint(self) -> bool:
        """Test root endpoint with service information"""
        try:
            response = requests.get(f"{self.base_url}/", timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # Check for DABTTB branding
                has_correct_branding = (
                    "DABTTB" in str(data) or 
                    "service" in data
                )
                
                self.log_test(
                    "Root Endpoint", 
                    has_correct_branding,
                    f"Service info retrieved, branding check: {has_correct_branding}",
                    data
                )
                return has_correct_branding
            else:
                self.log_test(
                    "Root Endpoint", 
                    False,
                    f"HTTP {response.status_code}"
                )
                return False
                
        except Exception as e:
            self.log_test(
                "Root Endpoint", 
                False,
                f"Request failed: {str(e)}"
            )
            return False
    
    def test_metrics_endpoint(self) -> bool:
        """Test metrics endpoint"""
        try:
            response = requests.get(f"{self.base_url}/metrics", timeout=10)
            
            if response.status_code == 200:
                metrics = response.json()
                
                self.log_test(
                    "Metrics Endpoint", 
                    True,
                    "Metrics retrieved successfully",
                    metrics
                )
                return True
            else:
                self.log_test(
                    "Metrics Endpoint", 
                    False,
                    f"HTTP {response.status_code}"
                )
                return False
                
        except Exception as e:
            self.log_test(
                "Metrics Endpoint", 
                False,
                f"Request failed: {str(e)}"
            )
            return False
    
    def test_analytics_endpoints(self) -> bool:
        """Test analytics dashboard endpoints"""
        endpoints_to_test = [
            "/analytics/summary",
            "/analytics/detections"
        ]
        
        all_passed = True
        
        for endpoint in endpoints_to_test:
            try:
                response = requests.get(f"{self.base_url}{endpoint}", timeout=10)
                
                if response.status_code == 200:
                    data = response.json()
                    self.log_test(
                        f"Analytics {endpoint}", 
                        True,
                        "Analytics data retrieved",
                        f"Data keys: {list(data.keys()) if isinstance(data, dict) else 'Non-dict response'}"
                    )
                else:
                    self.log_test(
                        f"Analytics {endpoint}", 
                        False,
                        f"HTTP {response.status_code}"
                    )
                    all_passed = False
                    
            except Exception as e:
                self.log_test(
                    f"Analytics {endpoint}", 
                    False,
                    f"Request failed: {str(e)}"
                )
                all_passed = False
        
        return all_passed
    
    def test_frontend_accessibility(self) -> bool:
        """Test if frontend is accessible"""
        try:
            # Test frontend on port 3005
            response = requests.get("http://localhost:3005", timeout=10)
            
            if response.status_code == 200:
                # Check for DABTTB branding in HTML
                html_content = response.text
                has_dabttb_branding = (
                    "DABTTB" in html_content or 
                    "London South Bank University" in html_content
                )
                
                self.log_test(
                    "Frontend Accessibility", 
                    has_dabttb_branding,
                    f"Frontend accessible, DABTTB branding: {has_dabttb_branding}"
                )
                return has_dabttb_branding
            else:
                self.log_test(
                    "Frontend Accessibility", 
                    False,
                    f"HTTP {response.status_code}"
                )
                return False
                
        except Exception as e:
            self.log_test(
                "Frontend Accessibility", 
                False,
                f"Frontend not accessible: {str(e)}"
            )
            return False
    
    def test_data_quality_features(self) -> bool:
        """Test data quality assurance features"""
        try:
            # Test if outlier detection files exist and are accessible
            response = requests.get(f"{self.base_url}/health", timeout=5)
            
            if response.status_code == 200:
                self.log_test(
                    "Data Quality Features", 
                    True,
                    "Data quality system accessible via health check"
                )
                return True
            else:
                self.log_test(
                    "Data Quality Features", 
                    False,
                    "Could not verify data quality features"
                )
                return False
                
        except Exception as e:
            self.log_test(
                "Data Quality Features", 
                False,
                f"Test failed: {str(e)}"
            )
            return False
    
    def run_comprehensive_tests(self) -> Dict[str, Any]:
        """Run all tests and return comprehensive results"""
        print("üöÄ Starting DABTTB System Validation Tests")
        print("=" * 60)
        print("Computer Science Project - London South Bank University")
        print("BSc Computer Systems Engineering")
        print("=" * 60)
        
        # Wait for services to be ready
        print("\n‚è≥ Waiting for services to be ready...")
        time.sleep(10)
        
        # Run all tests
        tests = [
            ("Service Health", self.test_service_health),
            ("Root Endpoint", self.test_root_endpoint),
            ("Metrics Endpoint", self.test_metrics_endpoint),
            ("Analytics Endpoints", self.test_analytics_endpoints),
            ("Frontend Accessibility", self.test_frontend_accessibility),
            ("Data Quality Features", self.test_data_quality_features)
        ]
        
        print(f"\nüß™ Running {len(tests)} test categories...")
        print("-" * 60)
        
        passed_tests = 0
        total_tests = len(tests)
        
        for test_name, test_func in tests:
            try:
                if test_func():
                    passed_tests += 1
            except Exception as e:
                self.log_test(
                    test_name, 
                    False,
                    f"Test execution failed: {str(e)}"
                )
        
        # Generate summary
        end_time = datetime.now()
        duration = (end_time - self.start_time).total_seconds()
        
        summary = {
            "project_name": "DABTTB - Advanced Table Tennis Ball Tracking",
            "institution": "London South Bank University",
            "program": "BSc Computer Systems Engineering",
            "test_summary": {
                "total_tests": total_tests,
                "passed_tests": passed_tests,
                "failed_tests": total_tests - passed_tests,
                "success_rate": f"{(passed_tests/total_tests)*100:.1f}%",
                "duration_seconds": duration
            },
            "detailed_results": self.test_results,
            "timestamp": end_time.isoformat(),
            "github_ready": passed_tests >= (total_tests * 0.8)  # 80% pass rate required
        }
        
        # Print summary
        print("\n" + "=" * 60)
        print("üìä DABTTB System Validation Summary")
        print("=" * 60)
        print(f"Tests Passed: {passed_tests}/{total_tests}")
        print(f"Success Rate: {summary['test_summary']['success_rate']}")
        print(f"Duration: {duration:.1f} seconds")
        print(f"GitHub Ready: {'‚úÖ YES' if summary['github_ready'] else '‚ùå NO'}")
        
        if summary['github_ready']:
            print("\nüéâ DABTTB system is ready for GitHub upload!")
            print("   All critical systems are functioning correctly.")
        else:
            print("\n‚ö†Ô∏è  DABTTB system needs attention before GitHub upload.")
            print("   Please resolve failing tests before proceeding.")
        
        print("\nüéì London South Bank University")
        print("   BSc Computer Systems Engineering")
        print("   Computer Science Project")
        
        return summary

def main():
    """Main function to run DABTTB system tests"""
    tester = DABTTBSystemTester()
    
    try:
        results = tester.run_comprehensive_tests()
        
        # Save results to file
        with open("dabttb_test_results.json", "w") as f:
            json.dump(results, f, indent=2)
        
        print(f"\nüìÑ Test results saved to: dabttb_test_results.json")
        
        # Exit with appropriate code
        sys.exit(0 if results['github_ready'] else 1)
        
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Tests interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Test suite failed: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()
